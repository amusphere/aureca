# 要件定義書

## 概要

現在のAIチャット上限システムが複雑すぎるため、シンプルな構造にリファクタリングします。プラン毎の上限設定をハードコーディングし、ClerkのAPIからユーザープランを取得し、現状の利用数を管理する簡潔なシステムを構築します。

## 要件

### 要件1: シンプルなプラン別利用回数制限

**ユーザーストーリー:** 開発者として、複雑な設定ファイルやJSONではなく、ハードコーディングされたシンプルなプラン制限を実装したい。これにより、処理速度の向上と保守性の向上を実現できる。

#### 受入基準

1. WHEN システムがプラン制限を確認する場合 THEN ハードコーディングされた定数から制限値を取得する
2. WHEN freeプランユーザーがアクセスする場合 THEN システムは0回の制限を適用する
3. WHEN standardプランユーザーがアクセスする場合 THEN システムは1日10回の制限を適用する

### 要件2: ClerkAPIからのユーザープラン取得

**ユーザーストーリー:** システム管理者として、ClerkのAPIを使用してユーザーのサブスクリプションプランを動的に取得したい。これにより、プラン変更が即座に反映される仕組みを実現できる。

#### 受入基準

1. WHEN ユーザーの制限チェックが必要な場合 THEN システムはClerkのAPIからユーザープラン情報を取得する
2. WHEN ClerkのAPIが利用できない場合 THEN システムはfreeプランとしてフォールバックする
3. WHEN プラン情報の取得に失敗する場合 THEN システムは適切なエラーハンドリングを行う
4. WHEN プラン情報を取得する場合 THEN システムは必要最小限のAPI呼び出しで効率的に処理する

### 要件3: シンプルな現状利用数管理

**ユーザーストーリー:** システム管理者として、複雑なログテーブルではなく、シンプルな利用数カウンターで現状の利用状況を管理したい。これにより、データベース負荷を軽減し、処理速度を向上させることができる。

#### 受入基準

1. WHEN ユーザーがAIChatを利用する場合 THEN システムは日次利用カウンターを1増加させる
2. WHEN 日付が変わる場合 THEN システムは利用カウンターを0にリセットする
3. WHEN 利用数を確認する場合 THEN システムは単一のクエリで高速に結果を返す
4. WHEN データベース負荷を軽減する場合 THEN システムは最小限のテーブル構造を使用する

### 要件4: 利用可不可チェック機能

**ユーザーストーリー:** 有料プランユーザーとして、AIChatを利用する前に利用可能かどうかを簡潔にチェックしたい。これにより、無駄なリクエストを避け、スムーズな利用体験を得られる。

#### 受入基準

1. WHEN ユーザーがAIChatリクエストを送信する場合 THEN システムは利用可能性を事前にチェックする
2. WHEN 利用回数が制限に達している場合 THEN システムは利用不可の判定を返す
3. WHEN 利用回数に余裕がある場合 THEN システムは利用可能の判定を返す
4. WHEN 判定処理を実行する場合 THEN システムは高速で軽量な処理を提供する

### 要件5: レスポンシブUIでの利用状況表示

**ユーザーストーリー:** 有料プランユーザーとして、現在の利用回数と残り回数をレスポンシブデザインで確認したい。これにより、デバイスに関係なく計画的にAIChatを利用できる。

#### 受入基準

1. WHEN ユーザーがAIChatインターフェースを表示する場合 THEN システムは残り利用回数をレスポンシブに表示する
2. WHEN 利用回数が0になる場合 THEN システムは利用不可メッセージを表示し、フォームを非活性化する
3. WHEN 画面サイズが変更される場合 THEN システムはレスポンシブデザインを維持する
4. WHEN モバイルデバイスで表示する場合 THEN システムは適切なタッチインターフェースを提供する

### 要件6: プログラミング原則に基づくベストプラクティス

**ユーザーストーリー:** 開発者として、SOLID原則やクリーンアーキテクチャに基づいた保守性の高いコードを実装したい。これにより、将来の機能拡張や保守作業を効率的に行える。

#### 受入基準

1. WHEN コードを実装する場合 THEN システムは単一責任原則（SRP）に従って各クラスの責務を明確にする
2. WHEN 依存関係を管理する場合 THEN システムは依存性逆転原則（DIP）に従って抽象に依存する
3. WHEN 機能を拡張する場合 THEN システムは開放閉鎖原則（OCP）に従って既存コードを変更せずに拡張できる
4. WHEN コードの可読性を向上させる場合 THEN システムは適切な命名規則とコメントを使用する